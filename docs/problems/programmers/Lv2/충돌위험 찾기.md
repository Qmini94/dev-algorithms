# 문제 풀이 기록

작성자: 박규민  
작성일: 2026-01-31

---

## 문제 정보

- URL: https://school.programmers.co.kr/learn/courses/30/lessons/340211
- 문제 이름: 충돌위험 찾기
- 난이도: Lv2
- 클래스명: CollisionRisk

---

## 문제 정의

- 문제 요약: 여러 로봇이 주어진 경로를 규칙에 따라 이동할 때, 같은 시간에 같은 좌표에 2대 이상 모이는 위험 상황의 발생 횟수를 계산한다.
- 입력: 좌표 목록, 각 로봇이 방문할 point 인덱스 경로
- 출력: 충돌 위험 상황의 총 횟수(위험한 좌표의 누적 카운트)

---

## Constraint 분석

| 항목       | 값                                                                   |
| -------- | ------------------------------------------------------------------- |
| 입력 크기    | points의 크기 n ≤ 100, 로봇 수 x ≤ 100, 로봇 경로 길이 m ≤ 100 (문제 제한사항 그대로 기입) |
| 시간 제한    | 명시 없음                                                               |
| 메모리 제한   | 명시 없음                                                               |
| 예상 시간복잡도 | 시뮬레이션 기반: 로봇 이동을 시간 단위로 따라가며 좌표 카운팅. 대략 O(총 이동 스텝 + 시간×로봇수)         |

---

## 1차 접근 (브루트포스)

아이디어  
-  각 로봇의 경로를 routes별로 좌표 리스트를 생성한 뒤에 매 초마다 같은 좌표에 충돌이 일어나는 횟수를 카운팅한다.

시간복잡도  
-  O(최대시간X로봇수)

한계점  
-  

```java
public class CollisionRisk {  
    public int solution(int[][] points, int[][] routes) {  
        /*  
         * routes를 반복문으로 돌며 각 points를 이동할때에 경로 좌표를 전부 Map<Integer, List<int[]> paths(key: routeIdx, 배열길이: second, paths[y, x]: 좌표)  
         *  를 담은 후에 각 초에서 충돌이 일어나는 횟수를 카운팅한다. (각 초에서 같은 좌표의 충돌 카운팅은 최대 1회로 제한한다)  
         */        Map<Integer, List<int[]>> paths = new HashMap<>();  
        for(int i = 0; i < routes.length; i++) {  
            for(int y = 1; y < routes[i].length; y++) {  
                int[] startPoint = points[routes[i][y - 1] - 1].clone();  
                int[] endPoint = points[routes[i][y] - 1].clone();  
                List<int[]> movedPaths = new ArrayList<>();  
                while(!(startPoint[1] > endPoint[1])) {  
                    movedPaths.add(startPoint.clone());  
                    paths.put(i, movedPaths);  
                    startPoint = movePointToNext(startPoint, endPoint);  
                }  
            }  
        }  
  
        /**  
         * paths로 각 초(List의 length)에서 충돌이 일어나는 횟수를 카운팅한다. (각 초에서 같은 좌표의 충돌 카운팅은 최대 1회로 제한한다)  
         */        int count = 0;  
        int second = 0;  
        while(!paths.isEmpty()) {  
            Set<String> movedPoint = new HashSet<>();  
            Set<String> crashedPath = new HashSet<>();  
            Iterator<Map.Entry<Integer, List<int[]>>> it = paths.entrySet().iterator();  
  
            while (it.hasNext()) {  
                Map.Entry<Integer, List<int[]>> entry = it.next();  
                List<int[]> path = entry.getValue();  
  
                if(second < path.size()) {  
                    String key = path.get(second)[0] + "," + path.get(second)[1];  
                    if(!movedPoint.contains(key)) {  
                        movedPoint.add(key);  
                    } else {  
                        crashedPath.add(key);  
                    }  
                } else {  
                    it.remove();  
                }  
            }  
  
            if(movedPoint.size() != paths.size()) {  
                count = count + crashedPath.size();  
            }  
            second++;  
        }  
  
        return count;  
    }  
  
    private int[] movePointToNext(int[] startPoint, int[] endPoint) {  
        int startY = startPoint[0];  
        int startX = startPoint[1];  
        int endY = endPoint[0];  
        int endX = endPoint[1];  
  
        if(startY != endY) {  
            startY = startY < endY ? startY + 1 : startY - 1;  
            startPoint[0] = startY;  
        } else {  
            startX = startX <= endX ? startX + 1 : startX - 1;  
            startPoint[1] = startX;  
        }  
  
        return startPoint;  
    }  
}
```

---

## 2차 접근 (개선 시도)

아이디어  
-  

개선 포인트  
-  

시간복잡도  
-  

```java
```

---

## 최적 풀이 (Solution)

핵심 알고리즘  
-  

자료구조 선택 이유  
-  

시간복잡도  
-  

공간복잡도  
-  

```java
```

---

## 배운 점

- 실수한 부분:
- 다음에 같은 유형 만나면 체크할 것:

---

## 테스트 케이스

| 입력 | 예상 출력 | 결과 |
|------|-----------|------|
|      |           |      |
|      |           |      |
