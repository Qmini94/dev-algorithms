name: Update Problem List

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'src/main/java/problems/programmers/**'
      - 'src/test/java/problems/programmers/**'
      - 'docs/problems/programmers/**'
  workflow_dispatch:  # ÏàòÎèô Ïã§Ìñâ Í∞ÄÎä•!

jobs:
  update-list:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Generate problem list
        run: |
          python3 << 'EOF'
          import os
          from pathlib import Path
          from collections import defaultdict
          
          # Í≤ΩÎ°ú ÏÑ§Ï†ï (Ï†ÄÏû•ÏÜå Î£®Ìä∏ = ÌòÑÏû¨ ÎîîÎ†âÌÜ†Î¶¨)
          repo_root = Path.cwd()
          src_main = repo_root / 'src' / 'main' / 'java' / 'problems' / 'programmers'
          src_test = repo_root / 'src' / 'test' / 'java' / 'problems' / 'programmers'
          docs_path = repo_root / 'docs' / 'problems' / 'programmers'
          output_file = repo_root / 'problems' / 'programmers.md'
          
          # Î†àÎ≤®Î≥ÑÎ°ú ÌååÏùº ÏàòÏßë
          problems = defaultdict(lambda: {'solution': None, 'test': None, 'doc': None})
          
          # src/main/java ÌååÏùº ÏàòÏßë
          if src_main.exists():
              for level_dir in sorted(src_main.iterdir()):
                  if level_dir.is_dir():
                      level = level_dir.name.upper()
                      for java_file in sorted(level_dir.glob('*.java')):
                          problem_name = java_file.stem
                          key = f"{level}:{problem_name}"
                          # Ï†ÄÏû•ÏÜå Î£®Ìä∏ Í∏∞Ï§Ä ÏÉÅÎåÄ Í≤ΩÎ°ú
                          rel_path = java_file.relative_to(repo_root)
                          problems[key]['solution'] = str(rel_path)
                          problems[key]['level'] = level
                          problems[key]['name'] = problem_name
          
          # src/test/java ÌååÏùº ÏàòÏßë
          if src_test.exists():
              for level_dir in sorted(src_test.iterdir()):
                  if level_dir.is_dir():
                      level = level_dir.name.upper()
                      for java_file in sorted(level_dir.glob('*Test.java')):
                          problem_name = java_file.stem.replace('Test', '')
                          key = f"{level}:{problem_name}"
                          # Ï†ÄÏû•ÏÜå Î£®Ìä∏ Í∏∞Ï§Ä ÏÉÅÎåÄ Í≤ΩÎ°ú
                          rel_path = java_file.relative_to(repo_root)
                          problems[key]['test'] = str(rel_path)
                          if 'level' not in problems[key]:
                              problems[key]['level'] = level
                              problems[key]['name'] = problem_name
          
          # docs/problems/programmers ÌååÏùº ÏàòÏßë
          if docs_path.exists():
              for level_dir in sorted(docs_path.iterdir()):
                  if level_dir.is_dir():
                      level = level_dir.name.upper()
                      for md_file in sorted(level_dir.glob('*.md')):
                          problem_name = md_file.stem
                          key = f"{level}:{problem_name}"
                          # Ï†ÄÏû•ÏÜå Î£®Ìä∏ Í∏∞Ï§Ä ÏÉÅÎåÄ Í≤ΩÎ°ú
                          rel_path = md_file.relative_to(repo_root)
                          problems[key]['doc'] = str(rel_path)
                          if 'level' not in problems[key]:
                              problems[key]['level'] = level
                              problems[key]['name'] = problem_name
          
          # Markdown ÏÉùÏÑ±
          output_file.parent.mkdir(parents=True, exist_ok=True)
          
          with open(output_file, 'w', encoding='utf-8') as f:
              f.write('# Programmers Î¨∏Ï†ú Î™©Î°ù\n\n')
              f.write('> ÏûêÎèô ÏÉùÏÑ±Îêú Î¨∏Ï†ú Î™©Î°ùÏûÖÎãàÎã§. ÏàòÎèôÏúºÎ°ú Ìé∏ÏßëÌïòÏßÄ ÎßàÏÑ∏Ïöî.\n\n')
              f.write('---\n\n')
          
              # Î†àÎ≤®Î≥ÑÎ°ú Í∑∏Î£πÌôî
              levels = defaultdict(list)
              for key, data in problems.items():
                  level = data.get('level', 'UNKNOWN')
                  levels[level].append(data)
          
              # Î†àÎ≤® ÏàúÏÑúÎåÄÎ°ú Ï†ïÎ†¨
              level_order = ['LV0', 'LV1', 'LV2', 'LV3', 'LV4', 'LV5']
          
              for level in level_order:
                  if level not in levels:
                      continue
          
                  f.write(f'## {level}\n\n')
                  f.write('| Î¨∏Ï†úÎ™Ö | ÌíÄÏù¥ | ÌÖåÏä§Ìä∏ | Î¨∏ÏÑú |\n')
                  f.write('|--------|------|--------|------|\n')
          
                  for data in sorted(levels[level], key=lambda x: x['name']):
                      name = data['name']
                      solution_link = f"[üìù]({data['solution']})" if data['solution'] else '-'
                      test_link = f"[üß™]({data['test']})" if data['test'] else '-'
                      doc_link = f"[üìñ]({data['doc']})" if data['doc'] else '-'
          
                      f.write(f'| {name} | {solution_link} | {test_link} | {doc_link} |\n')
          
                  f.write('\n')
          
              # ÌÜµÍ≥Ñ Ï∂îÍ∞Ä
              f.write('---\n\n')
              f.write('## üìä ÌÜµÍ≥Ñ\n\n')
              total_problems = len(problems)
              total_with_solution = sum(1 for p in problems.values() if p['solution'])
              total_with_test = sum(1 for p in problems.values() if p['test'])
              total_with_doc = sum(1 for p in problems.values() if p['doc'])
          
              f.write(f'- Ï†ÑÏ≤¥ Î¨∏Ï†ú: {total_problems}Í∞ú\n')
              f.write(f'- ÌíÄÏù¥ ÏôÑÎ£å: {total_with_solution}Í∞ú\n')
              f.write(f'- ÌÖåÏä§Ìä∏ ÏûëÏÑ±: {total_with_test}Í∞ú\n')
              f.write(f'- Î¨∏ÏÑúÌôî ÏôÑÎ£å: {total_with_doc}Í∞ú\n')
          
              if total_problems > 0:
                  completion_rate = (total_with_doc / total_problems) * 100
                  f.write(f'- Î¨∏ÏÑúÌôîÏú®: {completion_rate:.1f}%\n')
          
          print(f"‚úÖ {output_file} ÏÉùÏÑ± ÏôÑÎ£å!")
          print(f"üìù Ï¥ù {len(problems)}Í∞ú Î¨∏Ï†ú ÏàòÏßë")
          EOF

      - name: Check if there are changes
        id: check_changes
        run: |
          git diff --quiet problems/programmers.md || echo "changed=true" >> $GITHUB_OUTPUT

      - name: Commit and push if changed
        if: steps.check_changes.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add problems/programmers.md
          git commit -m "docs: auto-update programmers problem list"
          git push